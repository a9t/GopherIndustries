package main

// GlobalProductFactory a global product factory that contains all the Products
var GlobalProductFactory = newProductFactory()

// GlobalRecipeFactory a global recipe factory that contains all the Recipes
var GlobalRecipeFactory = newRecipeFactory()

const (
	// ProductResourceCopper copper
	ProductResourceCopper int = iota
	// ProductResourceIron iron
	ProductResourceIron
	// ProductResourceStone stone
	ProductResourceStone

	// ProductProcessedCopperWire copper wire
	ProductProcessedCopperWire
	// ProductProcessedCircuitBoard circuit board
	ProductProcessedCircuitBoard

	// ProductProcessedPlate iron plate
	ProductProcessedPlate
	// ProductProcessedGear gear
	ProductProcessedGear

	// ProductStructureExtractor extractor
	ProductStructureExtractor
	// ProductStructureChest chest
	ProductStructureChest
	// ProductStructureBelt belt
	ProductStructureBelt
)

// Product generated by one of the machines in the world
type Product struct {
	name           string
	representation rune
	structure      Structure
}

// ProductFactory factory for generating all the possible Products
type ProductFactory struct {
	products map[int]*Product
}

// GetProduct returns the Product identified by the product id
func (pf *ProductFactory) GetProduct(id int) *Product {
	return pf.products[id]
}

func newProductFactory() *ProductFactory {
	pf := new(ProductFactory)
	pf.products = make(map[int]*Product)

	pf.products[ProductResourceCopper] = &Product{"copper", 'c', nil}
	pf.products[ProductResourceIron] = &Product{"iron", 'i', nil}
	pf.products[ProductResourceStone] = &Product{"stone", 's', nil}

	pf.products[ProductProcessedCopperWire] = &Product{"wire", 'w', nil}
	pf.products[ProductProcessedCircuitBoard] = &Product{"circuit", 'C', nil}

	pf.products[ProductProcessedPlate] = &Product{"plate", 'p', nil}
	pf.products[ProductProcessedGear] = &Product{"gear", 'g', nil}

	pf.products[ProductStructureExtractor] = &Product{"extractor", 'e', NewExtractor()}
	pf.products[ProductStructureChest] = &Product{"chest", 'S', NewChest()}
	pf.products[ProductStructureBelt] = &Product{"belt", 'b', NewBelt()}

	return pf
}

// Recipe indicates the production process required for creating a new Product
type Recipe struct {
	input           map[*Product]int
	output          *Product
	productionTicks int
}

func newRecipe(p *Product, ticks int) *Recipe {
	recipe := new(Recipe)
	recipe.input = make(map[*Product]int)
	recipe.output = p
	recipe.productionTicks = ticks

	return recipe
}

func (r *Recipe) addInput(p *Product, c int) {
	r.input[p] = c
}

// RecipeFactory stores possible Recipes
type RecipeFactory struct {
	Assembly []*Recipe
	Research []*Recipe
}

func newRecipeFactory() *RecipeFactory {
	rp := new(RecipeFactory)
	rp.Assembly = make([]*Recipe, 0)
	rp.Research = make([]*Recipe, 0)

	pCopper := GlobalProductFactory.GetProduct(ProductResourceCopper)
	pWire := GlobalProductFactory.GetProduct(ProductProcessedCopperWire)
	recipe := newRecipe(pWire, 100)
	recipe.addInput(pCopper, 4)

	pIron := GlobalProductFactory.GetProduct(ProductResourceIron)
	pGear := GlobalProductFactory.GetProduct(ProductProcessedGear)
	recipe = newRecipe(pGear, 120)
	recipe.addInput(pIron, 4)

	return rp
}
